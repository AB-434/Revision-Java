from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql+asyncpg://postgres:password@localhost/appointments"

engine = create_async_engine(DATABASE_URL, echo=False)

AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session






import uuid
from sqlalchemy import Column, String, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, nullable=False)
    role = Column(String, nullable=False)  # client / provider

class Appointment(Base):
    __tablename__ = "appointments"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    client_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))
    provider_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))
    start_time = Column(DateTime)
    end_time = Column(DateTime)
    status = Column(String, default="BOOKED")





from pydantic import BaseModel, EmailStr
from uuid import UUID
from datetime import datetime

class UserCreate(BaseModel):
    name: str
    email: EmailStr
    role: str

class AppointmentCreate(BaseModel):
    client_id: UUID
    provider_id: UUID
    start_time: datetime
    end_time: datetime

class AppointmentUpdate(BaseModel):
    start_time: datetime | None = None
    end_time: datetime | None = None
    status: str | None = None




from fastapi import Header, HTTPException, Depends

API_KEY = "SECRET123"

async def verify_api_key(api_key: str = Header(None)):
    if api_key != API_KEY:
        raise HTTPException(status_code=401, detail="Invalid API Key")

def api_key_required(func):
    async def wrapper(*args, **kwargs):
        await verify_api_key(kwargs.get("api_key"))
        return await func(*args, **kwargs)
    return wrapper




from datetime import datetime, timedelta

def slot_generator(start: datetime, count: int):
    """Generate appointment slots efficiently"""
    for i in range(count):
        yield start + timedelta(minutes=30 * i)



from fastapi import FastAPI, Depends, WebSocket, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from database import get_db
from models import User, Appointment
from schemas import UserCreate, AppointmentCreate, AppointmentUpdate
from security import verify_api_key
from utils import slot_generator

app = FastAPI(title="Appointment Booking System")

# WebSocket connections
connections: list[WebSocket] = []

# ---------------- USERS ----------------

@app.post("/users", status_code=201)
async def create_user(user: UserCreate, db: AsyncSession = Depends(get_db)):
    new_user = User(**user.dict())
    db.add(new_user)
    await db.commit()
    return new_user

@app.get("/users")
async def get_users(db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(User))
    return result.scalars().all()

# ---------------- APPOINTMENTS ----------------

@app.post("/appointments", status_code=201)
async def create_appointment(
    data: AppointmentCreate,
    db: AsyncSession = Depends(get_db)
):
    appt = Appointment(**data.dict())
    db.add(appt)
    await db.commit()

    for ws in connections:
        await ws.send_text("Appointment booked")

    return appt

@app.get("/appointments")
async def get_appointments(
    user_id: str | None = None,
    status_filter: str | None = None,
    db: AsyncSession = Depends(get_db)
):
    query = select(Appointment)
    if user_id:
        query = query.where(Appointment.client_id == user_id)
    if status_filter:
        query = query.where(Appointment.status == status_filter)

    result = await db.execute(query)
    return result.scalars().all()

@app.put("/appointments/{appointment_id}")
async def update_appointment(
    appointment_id: str,
    data: AppointmentUpdate,
    db: AsyncSession = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    result = await db.execute(
        select(Appointment).where(Appointment.id == appointment_id)
    )
    appt = result.scalar_one_or_none()
    if not appt:
        raise HTTPException(status_code=404, detail="Appointment not found")

    for field, value in data.dict(exclude_unset=True).items():
        setattr(appt, field, value)

    await db.commit()

    for ws in connections:
        await ws.send_text("Appointment updated")

    return appt

@app.delete("/appointments/{appointment_id}", status_code=204)
async def cancel_appointment(
    appointment_id: str,
    db: AsyncSession = Depends(get_db),
    api_key: str = Depends(verify_api_key)
):
    result = await db.execute(
        select(Appointment).where(Appointment.id == appointment_id)
    )
    appt = result.scalar_one_or_none()
    if not appt:
        raise HTTPException(status_code=404)

    appt.status = "CANCELLED"
    await db.commit()

    for ws in connections:
        await ws.send_text("Appointment cancelled")

# ---------------- WEBSOCKET ----------------

@app.websocket("/ws")
async def websocket_endpoint(ws: WebSocket):
    await ws.accept()
    connections.append(ws)
    try:
        while True:
            await ws.receive_text()
    except:
        connections.remove(ws)




import pytest
from httpx import AsyncClient
from main import app

@pytest.mark.asyncio
async def test_create_user():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        res = await ac.post("/users", json={
            "name": "Test",
            "email": "test@mail.com",
            "role": "client"
        })
        assert res.status_code == 201

@pytest.mark.asyncio
async def test_unauthorized_update():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        res = await ac.put("/appointments/123")
        assert res.status_code == 401
